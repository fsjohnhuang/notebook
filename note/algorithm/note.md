1. 分治算法
策略：
  对一个规模为n的问题，若n小于阀值n0(n0是指可被解决的规模上限)时则直接解决，否则将该问题分解成1<=k<=n个问题规格相同、相互独立、规模更小的子问题，然后通过递归解决所有子问题后合并各子问题的结果从而得出原问题的结果。
特征：
1. 问题规模可缩小到小于n0;
2. 问题具有最优子结构性质，既可分解为成若干个与原问题规格相同的子问题;
3. 所有子问题的解可以合并为原问题的解;
4. 子问题相互独立，之间不包含公共的子问题。
求解步骤：
```
/*
 * p 问题
 * getScale() 获取问题规模
 * divide_then_conquer() 分解并求值
 * conquer() 求值
 * merge() 合并解
 */
function divide_then_conquer(p){
    if (getScale(p) <= n0) return conquer(p)

    const max_slice = (p / k + 0.5) | 0
    const results = []
    for (let i = 0; i < k; ++i){
        results.push(divide_then_conquer(p.slice(i*max_slice, max_slice)))
    }
    return merge(results)
}
```

涉及的具体算法：
二分搜索
大整数乘法
Strassen矩阵乘法
棋盘覆盖
合并排序
快速排序
线性时间选择
最接近点对问题
循环赛日程表
汉诺塔

2. 贪心算法(通过局部最优决策得到全局最优决策)
策略:
  对问题求解时，仅从当前状态求局部最优解。

3. 动态规划
策略：
  将问题分解为一系列的决策/处理过程，每个决策会依赖当前状态，并且决策会引起状态转移，也就是下一个决策受到上一个或之前决策所影响(各决策可能造成不同状态发生状态转移)。最后一个决策处理结束后，就能得到问题结果。
特征：
1. 最优子结构，可将问题分解为规模更小的问题;
2. 无后效性，某状态后发生的决策不会导致原问题的状态恢复到该状态;
3. 子问题间存在重叠性。

初始状态 -> 决策1 -> 决策2 -> ... -> 决策n -> 结束状态

4. 回溯法
策略:  
  按选优条件(深度、广度)向前搜索问题的解，若发现原先选择不优或达不到目标，则退回重新选择。满足回溯条件的某个状态点称为"回溯点"。
求解步骤:
1. 确定问题的解域
2. 确定选优规则
3. 根据选优规则枚举解域,找出符合约束条件的解（可存在多个解）
一般以深度优先的搜索方式

5. 分支限界法
策略:  
  和回溯法类似，但会从符合约束条件的解中获取最优解。
一般以广度优先的搜索方式

蛮力策略,即枚举和回溯

问题种类
1. 判定性问题： 递推、递归
2. 计算问题:  递推、递归
3. 最优化问题: 贪心、分治、动态规划、枚举
4. 构造性问题: 贪心、分治、广度优先、深度优先


散列表
插入、删除和读取很快；查找很慢。


二叉树
查找快

